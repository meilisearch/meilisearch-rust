# This code-samples file is used by the Meilisearch documentation
# Every example written here will be automatically fetched by
# the documentation on build
# You can read more on https://github.com/meilisearch/documentation/tree/main/learn
---
synonyms_guide_1: |-
  let mut synonyms = std::collections::HashMap::new();
  synonyms.insert(String::from("great"), vec![String::from("fantastic")]);
  synonyms.insert(String::from("fantastic"), vec![String::from("great")]);

  let task: TaskInfo = client
    .index("movies")
    .set_synonyms(&synonyms)
    .await
    .unwrap();
date_guide_index_1: |-
  let mut file = File::open("games.json")
    .unwrap();
  let mut content = String::new();
  file
    .read_to_string(&mut content)
    .unwrap();
  let docs: Vec<Game> = serde_json::from_str(&content)
    .unwrap();

  client
    .index("games")
    .add_documents(&docs, None)
    .await
    .unwrap();
date_guide_filterable_attributes_1: |-
  let settings = Settings::new()
    .with_filterable_attributes(["release_timestamp"]);

  let task: TaskInfo = client
    .index("games")
    .set_settings(&settings)
    .await
    .unwrap();
date_guide_filter_1: |-
  let results: SearchResults<Game> = client
    .index("games")
    .search()
    .with_filter("release_timestamp >= 1514761200 AND release_timestamp < 1672527600")
    .execute()
    .await
    .unwrap();
date_guide_sortable_attributes_1: |-
  let settings = Settings::new()
    .with_sortable_attributes(["release_timestamp"]);

  let task: TaskInfo = client
    .index("games")
    .set_settings(&settings)
    .await
    .unwrap();
date_guide_sort_1: |-
  let results: SearchResults<Game> = client
    .index("games")
    .search()
    .with_sort(["release_timestamp:desc"])
    .execute()
    .await
    .unwrap();
delete_tasks_1: |-
  let mut query = tasks::TasksDeleteQuery::new(&client);
  query.with_uids([1, 2]);

  let res = client.delete_tasks_with(&query).await.unwrap();
cancel_tasks_1: |-
  let mut query = tasks::TasksCancelQuery::new(&client);
  query.with_uids([1, 2]);

  let res = client.cancel_task_with(&query).await.unwrap();
get_one_index_1: |-
  let movies: Index = client
    .get_index("movies")
    .await
    .unwrap();
list_all_indexes_1: |-
  let mut indexes = IndexesQuery::new(&client)
    .with_limit(3)
    .execute()
    .await
    .unwrap();
create_an_index_1: |-
  client.create_index("movies", Some("id"))
    .await
    .unwrap();
update_an_index_1: |-
  let task = IndexUpdater::new("movies", &client)
    .with_primary_key("movie_review_id")
    .execute()
    .await
    .unwrap();
delete_an_index_1: |-
  client.index("movies")
    .delete()
    .await
    .unwrap();
swap_indexes_1: |-
  client.swap_indexes([
    &SwapIndexes {
      indexes: (
          "indexA".to_string(),
          "indexB".to_string(),
      ),
    }, &SwapIndexes {
      indexes: (
          "indexX".to_string(),
          "indexY".to_string(),
      ),
  }])
get_one_document_1: |-
  let index = client
    .index("movies");
  let document = DocumentQuery::new(&index)
    .with_fields(["id", "title", "poster", "release_date"])
    .execute::<Movie>("25684")
    .await
    .unwrap();
get_documents_1: |-
  let index = client.index("movies");
  let documents: DocumentsResults = DocumentsQuery::new(&index)
    .with_filter("genres = action")
    .with_limit(2)
    .execute::<Movies>()
    .await
    .unwrap();
get_documents_post_1: |-
  let index = client.index("books");
  let documents: DocumentsResults = DocumentsQuery::new(&index)
    .with_filter("(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English")
    .with_fields(["title", "genres", "rating", "language"])
    .with_limit(2)
    .execute::<Movies>()
    .await
    .unwrap();
add_or_replace_documents_1: |-
  let task: TaskInfo = client
    .index("movies")
    .add_or_replace(&[
      Movie {
        id: 287947,
        title: "Shazam".to_string(),
        poster: "https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg".to_string(),
        overview: "A boy is given the ability to become an adult superhero in times of need with a single magic word.".to_string(),
        release_date: "2019-03-23".to_string(),
      }
    ], None)
    .await
    .unwrap();
add_or_update_documents_1: |-
  // Define the type of our documents
  #[derive(Serialize, Deserialize)]
  struct IncompleteMovie {
    id: usize,
    title: String
  }

  let task: TaskInfo = client
    .index("movies")
    .add_or_update(&[
      IncompleteMovie {
        id: 287947,
        title: "Shazam ⚡️".to_string()
      }
    ], None)
    .await
    .unwrap();
delete_all_documents_1: |-
  let task: TaskInfo = client
    .index("movies")
    .delete_all_documents()
    .await
    .unwrap();
delete_one_document_1: |-
  let task: TaskInfo = client
    .index("movies")
    .delete_document(25684)
    .await
    .unwrap();
delete_documents_by_batch_1: |-
  let task: TaskInfo = client
    .index("movies")
    .delete_documents(&[23488, 153738, 437035, 363869])
    .await
    .unwrap();
delete_documents_by_filter_1: |-
  let index = client.index("movies");
  let task = DocumentDeletionQuery::new(&index)
    .with_filter("genres = action OR genres = adventure")
    .execute()
    .await
    .unwrap();
search_post_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("American ninja")
    .execute()
    .await
    .unwrap();
get_all_tasks_1: |-
  let tasks: TasksResults = client
    .get_tasks()
    .await
    .unwrap();
get_all_tasks_paginating_1: |-
  let mut query = TasksSearchQuery::new(&client)
      .with_limit(2)
      .with_from(10)
      .execute()
      .await
      .unwrap();
get_all_tasks_paginating_2: |-
  let mut query = TasksSearchQuery::new(&client)
      .with_limit(2)
      .from(8)
      .execute()
      .await
      .unwrap();
get_task_1: |-
  let task: Task = client
    .get_task(1)
    .await
    .unwrap();
async_guide_filter_by_date_1: |-
  let date = OffsetDateTime::parse(
      "2020-10-11T11:49:53.000Z",
      &::time::format_description::well_known::Rfc3339,
  )

  let mut query = TasksQuery::new(&client);
  let tasks = query
    .with_after_enqueued_at(&date)
    .execute()
    .await
    .unwrap();
async_guide_multiple_filters_1: |-
  let mut query = TasksQuery::new(&client);
  let tasks = query
    .with_index_uids(["movies"])
    .with_types(["documentAdditionOrUpdate","documentDeletion"])
    .with_statuses(["processing"])
    .execute()
    .await
    .unwrap();
async_guide_filter_by_ids_1: |-
  let mut query = TasksQuery::new(&client);
  let tasks = query
    .with_uids([5, 10, 13])
    .execute()
    .await
    .unwrap();
async_guide_filter_by_statuses_1: |-
  let mut query = TasksQuery::new(&client);
  let tasks = query
    .with_statuses(["failed", "canceled"])
    .execute()
    .await
    .unwrap();
async_guide_filter_by_types_1: |-
  let mut query = TasksQuery::new(&client);
  let tasks = query
    .with_types(["dumpCreation", "indexSwap"])
    .execute()
    .await
    .unwrap();
async_guide_filter_by_index_uids_1: |-
  let mut query = TasksQuery::new(&client);
  let tasks = query
    .with_index_uids(["movies"])
    .execute()
    .await
    .unwrap();
async_guide_canceled_by_1: |-
  let mut query = TasksQuery::new(&client);
  let tasks = query
    .with_canceled_by([9, 15])
    .execute()
    .await
    .unwrap();
get_settings_1: |-
  let settings: Settings = client
    .index("movies")
    .get_settings()
    .await
    .unwrap();
# Cannot be updated until API faceting and pagination are added
update_settings_1: |-
  let mut synonyms = std::collections::HashMap::new();
  synonyms.insert(String::from("wolverine"), vec!["xmen", "logan"]);
  synonyms.insert(String::from("logan"), vec!["wolverine"]);

  let min_word_size_for_typos = MinWordSizeForTypos {
    one_typo: Some(4),
    two_typos; Some(12)
  }
  let typo_tolerance = TypoToleranceSettings {
    enabled: Some(true),
    disable_on_attributes: Some(vec!["title".to_string()]),
    disable_on_words: Some(vec![])
    min_word_size_for_typos: Some(min_word_size_for_typos),
  };

  let settings = Settings::new()
    .with_ranking_rules([
      "words",
      "typo",
      "proximity",
      "attribute",
      "sort",
      "exactness",
      "release_date:desc",
      "rank:desc"
    ])
    .with_distinct_attribute(Some("movie_id"))
    .with_searchable_attributes([
      "title",
      "overview",
      "genres"
    ])
    .with_displayed_attributes([
      "title",
      "overview",
      "genres",
      "release_date"
    ])
    .with_stop_words([
      "the",
      "a",
      "an"
    ])
    .with_sortable_attributes([
      "title",
      "release_date"
    ])
    .with_synonyms(synonyms)
    .with_typo_tolerance(typo_tolerance)
    .with_search_cutoff(150);

  let task: TaskInfo = client
    .index("movies")
    .set_settings(&settings)
    .await
    .unwrap();
reset_settings_1: |-
  let task: TaskInfo = client
    .index("movies")
    .reset_settings()
    .await
    .unwrap();
get_synonyms_1: |-
  let synonyms: HashMap<String, Vec<String>> = client
    .index("movies")
    .get_synonyms()
    .await
    .unwrap();
update_synonyms_1: |-
  let mut synonyms = std::collections::HashMap::new();
  synonyms.insert(String::from("wolverine"), vec![String::from("xmen"), String::from("logan")]);
  synonyms.insert(String::from("logan"), vec![String::from("xmen"), String::from("wolverine")]);
  synonyms.insert(String::from("wow"), vec![String::from("world of warcraft")]);

  let task: TaskInfo = client
    .index("movies")
    .set_synonyms(&synonyms)
    .await
    .unwrap();
reset_synonyms_1: |-
  let task: TaskInfo = client
    .index("movies")
    .reset_synonyms()
    .await
    .unwrap();
get_pagination_settings_1: |-
  let pagination: PaginationSetting = client
    .index("books")
    .get_pagination()
    .await
    .unwrap();
update_pagination_settings_1: |-
  let pagination = PaginationSetting {max_total_hits:100};

  let task: TaskInfo = client
    .index("books")
    .set_pagination(pagination)
    .await
    .unwrap();
reset_pagination_settings_1: |-
  let task: TaskInfo = client
    .index("books")
    .reset_pagination()
    .await
    .unwrap();
getting_started_typo_tolerance: |-
  let min_word_size_for_typos = MinWordSizeForTypos {
    one_typo: Some(5),
    two_typos: Some(4)
  }
  let typo_tolerance = TypoToleranceSettings {
    enabled: Some(true),
    disable_on_attributes: Some(vec![]),
    disable_on_words: Some(vec!["title".to_string()]),
    min_word_size_for_typos: Some(min_word_size_for_typos),
  };

  let task: TaskInfo = client
    .index("movies")
    .set_typo_tolerance(&typo_tolerance)
    .await
    .unwrap();
get_typo_tolerance_1: |-
  let typo_tolerance: TypoToleranceSettings = client
    .index("books")
    .get_typo_tolerance()
    .await
    .unwrap();
update_typo_tolerance_1: |-
  let typo_tolerance = TypoToleranceSettings {
    enabled: Some(false),
    disable_on_attributes: None,
    disable_on_words: None,
    min_word_size_for_typos: None,
  };

  let task: TaskInfo = client
    .index("books")
    .set_typo_tolerance(&typo_tolerance)
    .await
    .unwrap();
reset_typo_tolerance_1: |-
  let task: TaskInfo = client
    .index("books")
    .reset_typo_tolerance()
    .await
    .unwrap();
get_stop_words_1: |-
  let stop_words: Vec<String> = client
    .index("movies")
    .get_stop_words()
    .await
    .unwrap();
update_stop_words_1: |-
  let stop_words = ["of", "the", "to"];
  let task: TaskInfo = client
    .index("movies")
    .set_stop_words(&stop_words)
    .await
    .unwrap();
reset_stop_words_1: |-
  let task: TaskInfo = client
    .index("movies")
    .reset_stop_words()
    .await
    .unwrap();
get_ranking_rules_1: |-
  let ranking_rules: Vec<String> = client
    .index("movies")
    .get_ranking_rules()
    .await
    .unwrap();
update_ranking_rules_1: |-
  let ranking_rules = [
    "words",
    "typo",
    "proximity",
    "attribute",
    "sort",
    "exactness",
    "release_date:asc",
    "rank:desc",
  ];

  let task: TaskInfo = client
    .index("movies")
    .set_ranking_rules(&ranking_rules)
    .await
    .unwrap();
reset_ranking_rules_1: |-
  let task: TaskInfo = client
    .index("movies")
    .reset_ranking_rules()
    .await
    .unwrap();
get_distinct_attribute_1: |-
  let distinct_attribute: Option<String> = client
    .index("shoes")
    .get_distinct_attribute()
    .await
    .unwrap();
update_distinct_attribute_1: |-
  let task: TaskInfo = client
    .index("shoes")
    .set_distinct_attribute("skuid")
    .await
    .unwrap();
reset_distinct_attribute_1: |-
  let task: TaskInfo = client
    .index("shoes")
    .reset_distinct_attribute()
    .await
    .unwrap();
get_searchable_attributes_1: |-
  let searchable_attributes: Vec<String> = client
    .index("movies")
    .get_searchable_attributes()
    .await
    .unwrap();
update_searchable_attributes_1: |-
  let searchable_attributes = [
    "title",
    "overview",
    "genres"
  ];

  let task: TaskInfo = client
    .index("movies")
    .set_searchable_attributes(&searchable_attributes)
    .await
    .unwrap();
reset_searchable_attributes_1: |-
  let task: TaskInfo = client
    .index("movies")
    .reset_searchable_attributes()
    .await
    .unwrap();
get_filterable_attributes_1: |-
  let filterable_attributes: Vec<String> = client
    .index("movies")
    .get_filterable_attributes()
    .await
    .unwrap();
update_filterable_attributes_1: |-
  let filterable_attributes = [
    "genres",
    "director"
  ];

  let task: TaskInfo = client
    .index("movies")
    .set_filterable_attributes(&filterable_attributes)
    .await
    .unwrap();
reset_filterable_attributes_1: |-
  let task: TaskInfo = client
    .index("movies")
    .reset_filterable_attributes()
    .await
    .unwrap();
get_displayed_attributes_1: |-
  let displayed_attributes: Vec<String> = client
    .index("movies")
    .get_displayed_attributes()
    .await
    .unwrap();
update_displayed_attributes_1: |-
  let displayed_attributes = [
    "title",
    "overview",
    "genres",
    "release_date"
  ];

  let task: TaskInfo = client
    .index("movies")
    .set_displayed_attributes(&displayed_attributes)
    .await
    .unwrap();
reset_displayed_attributes_1: |-
  let task: TaskInfo = client
    .index("movies")
    .reset_displayed_attributes()
    .await
    .unwrap();
get_faceting_settings_1: |-
  let faceting: FacetingSettings = client
    .index("books")
    .get_faceting()
    .await
    .unwrap();
update_faceting_settings_1: |-
  let mut faceting = FacetingSettings {
    max_values_per_facet: 2,
  };

  let task: TaskInfo = client
    .index("books")
    .set_faceting(&faceting)
    .await
    .unwrap();
reset_faceting_settings_1: |-
  let task: TaskInfo = client
    .index("books")
    .reset_faceting()
    .await
    .unwrap();
get_separator_tokens_1: |-
  let task: TaskInfo = client
    .index('articles')
    .get_separator_tokens()
    .await
    .unwrap();
update_separator_tokens_1: |-
  let task: TaskInfo = client
    .index('articles')
    .set_separator_tokens(&vec!['|'.to_string(), '&hellip;'.to_string()])
    .await
    .unwrap();
reset_separator_tokens_1: |-
  let task: TaskInfo = client
    .index('articles')
    .reset_separator_tokens()
    .await
    .unwrap();
get_non_separator_tokens_1: |-
  let task: TaskInfo = client
    .index('articles')
    .get_non_separator_tokens()
    .await
    .unwrap();
update_non_separator_tokens_1: |-
  let task: TaskInfo = client
    .index('articles')
    .set_non_separator_tokens(&vec!['@'.to_string(), '#'.to_string()])
    .await
    .unwrap();
reset_non_separator_tokens_1: |-
  let task: TaskInfo = client
    .index('articles')
    .reset_non_separator_tokens()
    .await
    .unwrap();
get_dictionary_1: |-
  let task: TaskInfo = client
    .index('books')
    .get_dictionary()
    .await
    .unwrap();
update_dictionary_1: |-
  let task: TaskInfo = client
    .index('books')
    .set_dictionary(['J. R. R.', 'W. E. B.'])
    .await
    .unwrap();
reset_dictionary_1: |-
  let task: TaskInfo = client
    .index('books')
    .reset_dictionary()
    .await
    .unwrap();
get_index_stats_1: |-
  let stats: IndexStats = client
    .index("movies")
    .get_stats()
    .await
    .unwrap();
get_indexes_stats_1: |-
  let stats: ClientStats = client
    .get_stats()
    .await
    .unwrap();
get_health_1: |-
  // health() return an Err() if the server is not healthy, so this example would panic due to the unwrap
  client
    .health()
    .await
    .unwrap();
get_version_1: |-
  let version: Version = client
    .get_version()
    .await
    .unwrap();
distinct_attribute_guide_1: |-
  let task: TaskInfo = client
    .index("jackets")
    .set_distinct_attribute("product_id")
    .await
    .unwrap();
field_properties_guide_searchable_1: |-
  let searchable_attributes = [
    "title",
    "overvieww",
    "genres"
  ];

  let task: TaskInfo = client
    .index("movies")
    .set_searchable_attributes(&searchable_attributes)
    .await
    .unwrap();
field_properties_guide_displayed_1: |-
  let displayed_attributes = [
    "title",
    "overvieww",
    "genres",
    "release_date"
  ];

  let task: TaskInfo = client
    .index("movies")
    .set_displayed_attributes(&displayed_attributes)
    .await
    .unwrap();
filtering_guide_1: |-
  let results: SearchResults<Movie> = client
    .index("movie_ratings")
    .search()
    .with_query("Avengers")
    .with_filter("release_date > 795484800")
    .execute()
    .await
    .unwrap();
filtering_guide_2: |-
  let results: SearchResults<Movie> = client
    .index("movie_ratings")
    .search()
    .with_query("Batman")
    .with_filter(r#"release_date > 795484800 AND (director = "Tim Burton" OR director = "Christopher Nolan")"#)
    .execute()
    .await
    .unwrap();
filtering_guide_3: |-
  let results: SearchResults<Movie> = client
    .index("movie_ratings")
    .search()
    .with_query("Planet of the Apes")
    .with_filter(r#"release_date > 1577884550 AND (NOT director = "Tim Burton")"#)
    .execute()
    .await
    .unwrap();
filtering_guide_nested_1: |-
  let results: SearchResults<MovieRatings> = client
    .index("movie_rating")
    .search()
    .with_query("thriller")
    .with_filter("rating.users >= 90")
    .execute()
    .await
    .unwrap();
search_parameter_guide_query_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("shifu")
    .execute()
    .await
    .unwrap();
search_parameter_guide_attributes_to_search_on_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("adventure")
    .with_attributes_to_search_on(&["overview"])
    .execute()
    .await
    .unwrap();
search_parameter_guide_offset_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("shifu")
    .with_offset(1)
    .execute()
    .await
    .unwrap();
search_parameter_guide_limit_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("shifu")
    .with_limit(2)
    .execute()
    .await
    .unwrap();
search_parameter_guide_retrieve_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("shifu")
    .with_attributes_to_retrieve(Selectors::Some(&["overview", "title"]))
    .execute()
    .await
    .unwrap();
search_parameter_guide_crop_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("shifu")
    .with_attributes_to_crop(Selectors::Some(&[("overview", None)]))
    .with_crop_length(5)
    .execute()
    .await
    .unwrap();

  // Get the formatted results
  let formatted_results: Vec<&Movie> = results
    .hits
    .iter()
    .map(|r| r.formatted_result.as_ref().unwrap())
    .collect();
search_parameter_guide_crop_marker_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("shifu")
    .with_attributes_to_crop(Selectors::Some(&[("overview", None)]))
    .with_crop_marker("[…]")
    .execute()
    .await
    .unwrap();

  // Get the formatted results
  let formatted_results: Vec<&Movie> = results
    .hits
    .iter()
    .map(|r| r.formatted_result.as_ref().unwrap())
    .collect();
search_parameter_guide_highlight_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("winter feast")
    .with_attributes_to_highlight(Selectors::Some(&["overview"]))
    .execute()
    .await
    .unwrap();

  // Get the formatted results
  let formatted_results: Vec<&Movie> = results
    .hits
    .iter()
    .map(|r| r.formatted_result.as_ref().unwrap())
    .collect();
search_parameter_guide_highlight_tag_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("winter feast")
    .with_attributes_to_highlight(Selectors::Some(&["overview"]))
    .with_highlight_pre_tag("<span class=\"highlight\">")
    .with_highlight_post_tag("</span>")
    .execute()
    .await
    .unwrap();

  // Get the formatted results
  let formatted_results: Vec<&Movie> = results
    .hits
    .iter()
    .map(|r| r.formatted_result.as_ref().unwrap())
    .collect();
search_parameter_guide_show_matches_position_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("winter feast")
    .with_show_matches_position(true)
    .execute()
    .await
    .unwrap();

  // Get the matches info
  let matches_position: Vec<&HashMap<String, Vec<MatchRange>>> = results
    .hits
    .iter()
    .map(|r| r.matches_position.as_ref().unwrap())
    .collect();
search_parameter_guide_show_ranking_score_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("dragon")
    .with_show_ranking_score(true)
    .execute()
    .await
    .unwrap();
search_parameter_guide_show_ranking_score_details_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("dragon")
    .with_show_ranking_score_details(true)
    .execute()
    .await
    .unwrap();
search_parameter_guide_matching_strategy_1: |-
  let results: SearchResults<Movie> = client
  .index("movies")
  .search()
  .with_query("big fat liar")
  .with_matching_strategy(MatchingStrategies::LAST)
  .execute()
  .await
  .unwrap();
search_parameter_guide_matching_strategy_2: |-
  let results: SearchResults<Movie> = client
  .index("movies")
  .search()
  .with_query("big fat liar")
  .with_matching_strategy(MatchingStrategies::ALL)
  .execute()
  .await
  .unwrap();
search_parameter_guide_matching_strategy_3: |-
  let results: SearchResults<Movie> = client
  .index("movies")
  .search()
  .with_query("white shirt")
  .with_matching_strategy(MatchingStrategies::FREQUENCY)
  .execute()
  .await
  .unwrap();
search_parameter_guide_hitsperpage_1: |-
  client.index("movies").search().with_hits_per_page(15).execute().await?;
search_parameter_guide_page_1: |-
  client.index("movies").search().with_page(2).execute().await?;
typo_tolerance_guide_1: |-
  let typo_tolerance = TypoToleranceSettings {
    enabled: Some(false),
    disable_on_attributes: None,
    disable_on_words: None,
    min_word_size_for_typos: None,
  };

  let task: TaskInfo = client
    .index("movies")
    .set_typo_tolerance(&typo_tolerance)
    .await
    .unwrap();
typo_tolerance_guide_2: |-
  let min_word_size_for_typos = MinWordSizeForTypos {
    one_typo: Some(5),
    two_typos: Some(12)
  }
  let typo_tolerance = TypoToleranceSettings {
    enabled: Some(true),
    disable_on_attributes: Some(vec!["title".to_string()]),
    disable_on_words: None,
    min_word_size_for_typos: None,
  };

  let task: TaskInfo = client
    .index("movies")
    .set_typo_tolerance(&typo_tolerance)
    .await
    .unwrap();
typo_tolerance_guide_3: |-
  let min_word_size_for_typos = MinWordSizeForTypos {
    one_typo: Some(5),
    two_typos: Some(12)
  }
  let typo_tolerance = TypoToleranceSettings {
    enabled: Some(true),
    disable_on_attributes: None,
    disable_on_words: Some(vec!["shrek".to_string()]),
    min_word_size_for_typos: Some(min_word_size_for_typos),
  };

  let task: TaskInfo = client
    .index("movies")
    .set_typo_tolerance(&typo_tolerance)
    .await
    .unwrap();
typo_tolerance_guide_4: |-
  let min_word_size_for_typos = MinWordSizeForTypos {
    one_typo: Some(4),
    two_typos: Some(12)
  };
  let typo_tolerance = TypoToleranceSettings {
    enabled: Some(true),
    disable_on_attributes: Some(vec![]),
    disable_on_words: Some(vec!["title".to_string()]),
    min_word_size_for_typos: Some(min_word_size_for_typos),
  };

  let task: TaskInfo = client
    .index("movies")
    .set_typo_tolerance(&typo_tolerance)
    .await
    .unwrap();
add_movies_json_1: |-
  use meilisearch_sdk::{
    indexes::*,
    client::*,
    search::*,
    settings::*
  };
  use serde::{Serialize, Deserialize};
  use std::{io::prelude::*, fs::File};
  use futures::executor::block_on;

  fn main() { block_on(async move {
    let client = Client::new("http://localhost:7700", Some("masterKey"));

    // reading and parsing the file
    let mut file = File::open("movies.json")
      .unwrap();
    let mut content = String::new();
    file
      .read_to_string(&mut content)
      .unwrap();
    let movies_docs: Vec<Movie> = serde_json::from_str(&content)
      .unwrap();

    // adding documents
    client
      .index("movies")
      .add_documents(&movies_docs, None)
      .await
      .unwrap();
  })}
primary_field_guide_update_document_primary_key: |-
  let task = IndexUpdater::new("books", &client)
    .with_primary_key("title")
    .execute()
    .await
    .unwrap();
primary_field_guide_create_index_primary_key: |-
  client
    .create_index("books", Some("reference_number"))
    .await
    .unwrap();
primary_field_guide_add_document_primary_key: |-
  #[derive(Serialize, Deserialize)]
  struct Book {
    reference_number: String,
    title: String,
    author: String,
    genres: Vec<String>,
    price: f64
  }

  let task: TaskInfo = client
    .index("books")
    .add_documents(&[
      Book {
        reference_number: "287947".to_string(),
        title: "Diary of a Wimpy Kid".to_string(),
        author: "Jeff Kinney".to_string(),
        genres: vec!["comedy".to_string(),"humor".to_string()],
        price: 5.00
      }
    ], Some("reference_number"))
    .await
    .unwrap();
getting_started_add_documents: |-
  // In your .toml file:
    [dependencies]
    meilisearch-sdk = "0.28.0"
    # futures: because we want to block on futures
    futures = "0.3"
    # serde: required if you are going to use documents
    serde = { version="1.0",   features = ["derive"] }
    # serde_json: required in some parts of this guide
    serde_json = "1.0"
  ```

  // In your .rs file:
  // Documents in the Rust library are strongly typed
  #[derive(Serialize, Deserialize)]
  struct Movie {
    id: i64,
    title: String,
    poster: String,
    overview: String,
    release_date: i64,
    genres: Vec<String>
  }

  // You will often need this `Movie` struct in other parts of this documentation. (you will have to change it a bit sometimes)
  // You can also use schemaless values, by putting a `serde_json::Value` inside your own struct like this:
  #[derive(Serialize, Deserialize)]
  struct Movie {
    id: i64,
    #[serde(flatten)]
    value: serde_json::Value,
  }

  // Then, add documents into the index:
  use meilisearch_sdk::{
    indexes::*,
    client::*,
    search::*,
    settings::*
  };
  use serde::{Serialize, Deserialize};
  use std::{io::prelude::*, fs::File};
  use futures::executor::block_on;

  fn main() { block_on(async move {
    let client = Client::new("http://localhost:7700", Some("aSampleMasterKey"));

    // Reading and parsing the file
    let mut file = File::open("movies.json")
      .unwrap();
    let mut content = String::new();
    file
      .read_to_string(&mut content)
      .unwrap();
    let movies_docs: Vec<Movie> = serde_json::from_str(&content)
      .unwrap();

    // Adding documents
    client
      .index("movies")
      .add_documents(&movies_docs, None)
      .await
      .unwrap();
  })}
getting_started_search: |-
  // You can build a `SearchQuery` and execute it later:
  let query: SearchQuery = SearchQuery::new(&movies)
    .with_query("botman")
    .build();

  let results: SearchResults<Movie> = client
    .index("movies")
    .execute_query(&query)
    .await
    .unwrap();

  // You can build a `SearchQuery` and execute it directly:
  let results: SearchResults<Movie> = SearchQuery::new(&movies)
    .with_query("botman")
    .execute()
    .await
    .unwrap();

  // You can search in an index directly:
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("botman")
    .execute()
    .await
    .unwrap();
getting_started_update_ranking_rules: |-
  let ranking_rules = [
    "exactness",
    "words",
    "typo",
    "proximity",
    "attribute",
    "sort",
    "release_date:asc",
    "rank:desc"
  ];

  client
    .index("movies")
    .set_ranking_rules(&ranking_rules)
    .await
    .unwrap();
getting_started_update_searchable_attributes: |-
  let searchable_attributes = [
    "title"
  ];

  client
    .index("movies")
    .set_searchable_attributes(&searchable_attributes)
    .await
    .unwrap();
getting_started_update_stop_words: |-
  let stop_words = ["the"];
  client
    .index("movies")
    .set_stop_words(&stop_words)
    .await
    .unwrap();
getting_started_check_task_status: |-
  client
    .get_task(0)
    .await
    .unwrap();
getting_started_synonyms: |-
  let mut synonyms = std::collections::HashMap::new();
  synonyms.insert(String::from("winnie"), vec![String::from("piglet")]);
  synonyms.insert(String::from("piglet"), vec![String::from("winnie")]);

  client
    .index("movies")
    .set_synonyms(&synonyms)
    .await
    .unwrap();
getting_started_update_displayed_attributes: |-
  let displayed_attributes = [
    "title",
    "overview",
    "poster",
  ];

  client
    .index("movies")
    .set_displayed_attributes(&displayed_attributes)
    .await
    .unwrap();
getting_started_add_meteorites: |-
  use serde::{Serialize, Deserialize};
  use std::fs::File;

  #[derive(Serialize, Deserialize)]
  struct Geo {
    lat: f64,
    lon: f64
  }

  struct Meteorite {
    name: String,
    id: String,
    nametype: String,
    recclass: String,
    mass: i64,
    fall: String,
    _geo: Geo
  }

  let mut file = File::open("meteorites.json")?;
  let meteorites: Vec<Meteorite> = serde_json::from_reader(file)?;

  client
    .index("meteorites")
    .add_documents(&meteorites, None)
    .await?;
getting_started_configure_settings: |-
  let settings = Settings::new()
    .with_filterable_attributes([
      "mass",
      "_geo"
    ])
    .with_sortable_attributes([
      "mass",
      "_geo"
    ])
  let task: TaskInfo = client
    .index("meteorites")
    .set_settings(&settings)
    .await
    .unwrap();
getting_started_geo_radius: |-
  let results: SearchResults<Meteorite> = client
    .index("meteorites")
    .search()
    .with_filter("_geoRadius(46.9480, 7.4474, 210000)")
    .execute()
    .await
    .unwrap();
getting_started_geo_point: |-
  let results: SearchResults<Meteorite> = client
    .index("meteorites")
    .search()
    .with_sort(&["_geoPoint(48.8583701, 2.2922926):asc"])
    .execute()
    .await
    .unwrap();
getting_started_sorting: |-
  let results: SearchResults<Meteorite> = client
    .index("meteorites")
    .search()
    .with_filter("mass < 200")
    .with_sort(&["mass:asc"])
    .execute()
    .await
    .unwrap();
getting_started_faceting: |-
  let mut faceting = FacetingSettings {
    max_values_per_facet: 2,
  };

  let task: TaskInfo = client
    .index("movies")
    .set_faceting(&faceting)
    .await
    .unwrap();
getting_started_pagination: |-
  let pagination = PaginationSetting {max_total_hits:500};

  let task: TaskInfo = client
    .index("books")
    .set_pagination(pagination)
    .await
    .unwrap();
getting_started_filtering: |-
  let results: SearchResults<Meteorite> = client
    .index("meteorites")
    .search()
    .with_filter("mass < 200")
    .execute()
    .await
    .unwrap();
filtering_update_settings_1: |-
  let task: TaskInfo = client
    .index("movies")
    .set_filterable_attributes(["director", "genres"])
    .await
    .unwrap();
faceted_search_walkthrough_filter_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("thriller")
    .with_filter("(genres = Horror AND genres = Mystery) OR director = \"Jordan Peele\"")
    .execute()
    .await
    .unwrap();
faceted_search_update_settings_1: |-
  let task: TaskInfo = client
    .index("movie_ratings")
    .set_filterable_attributes(&["genres", "rating", "language"])
    .await
    .unwrap();
faceted_search_1: |-
  let books = client.index("books");

  let results: SearchResults<Book> = SearchQuery::new(&books)
    .with_query("classic")
    .with_facets(Selectors::Some(&["genres", "rating", "language"]))
    .execute()
    .await
    .unwrap();
post_dump_1: |-
  client
    .create_dump()
    .await
    .unwrap();
phrase_search_1: |-
  let results: SearchResults<Movie> = client
    .index("movies")
    .search()
    .with_query("\"african american\" horror")
    .execute()
    .await
    .unwrap();
sorting_guide_update_sortable_attributes_1: |-
  let sortable_attributes = [
    "author",
    "price"
  ];

  let task: TaskInfo = client
    .index("books")
    .set_sortable_attributes(&sortable_attributes)
    .await
    .unwrap();
sorting_guide_update_ranking_rules_1: |-
  let ranking_rules = [
    "words",
    "sort",
    "typo",
    "proximity",
    "attribute",
    "exactness"
  ];

  let task: TaskInfo = client
    .index("books")
    .set_ranking_rules(&ranking_rules)
    .await
    .unwrap();
sorting_guide_sort_parameter_1: |-
  let results: SearchResults<Books> = client
    .index("books")
    .search()
    .with_query("science fiction")
    .with_sort(&["price:asc"])
    .execute()
    .await
    .unwrap();
sorting_guide_sort_parameter_2: |-
  let results: SearchResults<Books> = client
    .index("books")
    .search()
    .with_query("butler")
    .with_sort(&["author:desc"])
    .execute()
    .await
    .unwrap();
sorting_guide_sort_nested_1: |-
  let results: SearchResults<Books> = client
    .index("books")
    .search()
    .with_query("science fiction")
    .with_sort(&["rating.users:asc"])
    .execute()
    .await
    .unwrap();
get_sortable_attributes_1: |-
  let sortable_attributes: Vec<String> = client
    .index("books")
    .get_sortable_attributes()
    .await
    .unwrap();
update_sortable_attributes_1: |-
  let sortable_attributes = [
    "price",
    "author"
  ];

  let task: TaskInfo = client
    .index("books")
    .set_sortable_attributes(&sortable_attributes)
    .await
    .unwrap();
reset_sortable_attributes_1: |-
  let task: TaskInfo = client
    .index("books")
    .reset_sortable_attributes()
    .await
    .unwrap();
search_parameter_guide_sort_1: |-
  let results: SearchResults<Books> = client
    .index("books")
    .search()
    .with_query("science fiction")
    .with_sort(&["price:asc"])
    .execute()
    .await
    .unwrap();
geosearch_guide_filter_settings_1: |-
  let task: TaskInfo = client
    .index("restaurants")
    .set_filterable_attributes(&["_geo"])
    .await
    .unwrap();
geosearch_guide_filter_usage_1: |-
  let results: SearchResults<Restaurant> = client
    .index("restaurants")
    .search()
    .with_filter("_geoRadius(45.472735, 9.184019, 2000)")
    .execute()
    .await
    .unwrap();
geosearch_guide_filter_usage_2: |-
  let results: SearchResults<Restaurant> = client
    .index("restaurants")
    .search()
    .with_filter("_geoRadius(45.472735, 9.184019, 2000) AND type = pizza")
    .execute()
    .await
    .unwrap();
geosearch_guide_sort_settings_1: |-
  let task: TaskInfo = client
    .index("restaurants")
    .set_sortable_attributes(&["_geo"])
    .await
    .unwrap();
geosearch_guide_sort_usage_1: |-
  let results: SearchResults<Restaurant> = client
    .index("restaurants")
    .search()
    .with_sort(&["_geoPoint(48.8561446, 2.2978204):asc"])
    .execute()
    .await
    .unwrap();
geosearch_guide_sort_usage_2: |-
  let results: SearchResults<Restaurant> = client
    .index("restaurants")
    .search()
    .with_sort(&["_geoPoint(48.8561446, 2.2978204):asc", "rating:desc"])
    .execute()
    .await
    .unwrap();
geosearch_guide_filter_usage_3: |-
  let results: SearchResults<Restaurant> = client
    .index("restaurants")
    .search()
    .with_filter("_geoBoundingBox([45.494181, 9.214024], [45.449484, 9.179175])")
    .execute()
    .await
    .unwrap();
get_one_key_1: |-
  let key = client
    .get_key("6062abda-a5aa-4414-ac91-ecd7944c0f8d")
    .await
    .unwrap();
get_all_keys_1: |-
  let mut query = KeysQuery::new()
    .with_limit(3)
    .execute(&client)
    .await
    .unwrap();
create_a_key_1: |-
  let mut key_options = KeyBuilder::new();
  key_options
    .with_name("Add documents: Products API key")
    .with_action(Action::DocumentsAdd)
    .with_expires_at(time::macros::datetime!(2042 - 04 - 02 00:42:42 UTC))
    .with_index("products");
  let new_key = client
    .create_key(key_options)
    .await
    .unwrap();
update_a_key_1: |-
  let mut key = client
    .get_key("6062abda-a5aa-4414-ac91-ecd7944c0f8d")
    .await
    .unwrap();
  key
      .with_description("Manage documents: Products/Reviews API key".to_string())
      .with_name("Products/Reviews API key".to_string())
      .update(&client)
      .await
      .unwrap();
delete_a_key_1: |-
  let key = client
    .get_key("6062abda-a5aa-4414-ac91-ecd7944c0f8d")
    .await
    .unwrap();
  client
    .delete_key(&key)
    .await?;
authorization_header_1:
  let client = Client::new("http://localhost:7700", Some("masterKey"));
  let keys = client
  .get_keys()
  .await
  .unwrap();
security_guide_search_key_1: |-
  let client = Client::new("http://localhost:7700", Some("apiKey"));
  let result = client.index("patient_medical_records")
    .search()
    .execute()
    .await
    .unwrap();
security_guide_update_key_1: |-
  let client = Client::new("http://localhost:7700", Some("masterKey"));
  let mut key = client
    .get_key("74c9c733-3368-4738-bbe5-1d18a5fecb37")
    .await
    .unwrap();
  key
    .with_description("Default Search API key".to_string())
    .update(&client);
security_guide_create_key_1: |-
  let client = Client::new("http://localhost:7700", Some("masterKey"));
  let mut key_options = KeyBuilder::new();
  key_options
    .with_name("Search patient records key")
    .with_action(Action::Search)
    .with_expires_at(time::macros::datetime!(2023 - 01 - 01 00:00:00 UTC))
    .with_index("patient_medical_records");
  let new_key = client
    .create_key(key_options)
    .await
    .unwrap();
security_guide_list_keys_1: |-
  let client = Client::new("http://localhost:7700", Some("masterKey"));
  let keys = client
    .get_keys()
    .await
    .unwrap();
security_guide_delete_key_1: |-
  let client = Client::new("http://localhost:7700", Some("masterKey"));
  let key = client
    .get_key("ac5cd97d-5a4b-4226-a868-2d0eb6d197ab")
    .await
    .unwrap();
  client
    .delete_key(&key)
    .await?;
landing_getting_started_1: |-
  let client = Client::new("http://localhost:7700", Some("masterKey"));

  #[derive(Serialize, Deserialize)]
  struct Movie {
    id: String,
    title: String
  }

  client.index("movies")
    .add_documents(&[
      Movie { id: "1".to_string(), title: "Carol".to_string() },
      Movie { id: "2".to_string(), title: "Wonder Woman".to_string() },
      Movie { id: "3".to_string(), title: "Life of Pi".to_string() },
      Movie { id: "4".to_string(), title: "Mad Max: Fury Road".to_string() },
      Movie { id: "5".to_string(), title: "Moana".to_string() },
      Movie { id: "6".to_string(), title: "Philadelphia".to_string() }
    ], Some("reference_number"))
    .await
    .unwrap();
tenant_token_guide_generate_sdk_1: |-
  let api_key = "B5KdX2MY2jV6EXfUs6scSfmC...";
  let api_key_uid = "6062abda-a5aa-4414-ac91-ecd7944c0f8d";
  let expires_at = time::macros::datetime!(2025 - 12 - 20 00:00:00 UTC);
  let search_rules = json!({ "patient_medical_records": { "filter": "user_id = 1" } });

  let token = client
    .generate_tenant_token(api_key_uid, search_rules, api_key, expires_at)
    .unwrap();
tenant_token_guide_search_sdk_1: |-
  let front_end_client = Client::new("http://localhost:7700", Some(token));
  let results: SearchResults<Patient> = front_end_client
    .index("patient_medical_records")
    .search()
    .with_query("blood test")
    .execute()
    .await
    .unwrap();
multi_search_1: |-
  let movie = client.index("movie");
  let movie_ratings = client.index("movie_ratings");

  let search_query_1 = SearchQuery::new(&movie)
      .with_query("pooh")
      .with_limit(5)
      .build();
  let search_query_2 = SearchQuery::new(&movie)
      .with_query("nemo")
      .with_limit(5)
      .build();
  let search_query_3 = SearchQuery::new(&movie_ratings)
      .with_query("us")
      .build();

  let response = client
      .multi_search()
      .with_search_query(search_query_1)
      .with_search_query(search_query_2)
      .with_search_query(search_query_3)
      .execute::<Document>()
      .await
      .unwrap();
get_experimental_features_1: |-
  let client = Client::new("http://localhost:7700", Some("apiKey"));
  let features = ExperimentalFeatures::new(&client);
  let res = features
    .get()
    .await
    .unwrap();
update_experimental_features_1: |-
  let client = Client::new("http://localhost:7700", Some("apiKey"));
  let features = ExperimentalFeatures::new(&client);
  features.set_metrics(true)
  let res = features
    .update()
    .await
    .unwrap();
search_parameter_guide_facet_stats_1: |-
  let books = client.index("movie_ratings");
  let results: SearchResults<Book> = SearchQuery::new(&books)
    .with_query("Batman")
    .with_facets(Selectors::Some(&["genres", "rating"))
    .execute()
    .await
    .unwrap();
get_proximity_precision_settings_1: |-
  let proximity_precision: String = client
    .index("books")
    .get_proximity_precision()
    .await
    .unwrap();
update_proximity_precision_settings_1: |-
  let task: TaskInfo = client
    .index("books")
    .set_proximity_precision("byAttribute".to_string())
    .await
    .unwrap();
reset_proximity_precision_settings_1: |-
  let task: TaskInfo = client
    .index("books")
    .reset_proximity_precision()
    .await
    .unwrap();
get_search_cutoff_1: |-
  let search_cutoff_ms: String = client
    .index("movies")
    .get_search_cutoff_ms()
    .await
    .unwrap();
update_search_cutoff_1: |-
  let task: TaskInfo = client
    .index("movies")
    .set_search_cutoff_ms(Some(150))
    .await
    .unwrap();
reset_search_cutoff_1: |-
  let task: TaskInfo = client
    .index("movies")
    .reset_search_cutoff_ms()
    .await
    .unwrap();
create_snapshot_1: |-
  client
    .create_snapshot()
    .await
    .unwrap();
search_parameter_reference_distinct_1: |-
  let res = client
    .index("INDEX_NAME")
    .search()
    .with_query("QUERY TERMS")
    .with_distinct("ATTRIBUTE_A")
    .execute()
    .await
    .unwrap();
distinct_attribute_guide_filterable_1: |-
  let task: TaskInfo = client
    .index("products")
    .settings()
    .set_filterable_attributes(["product_id", "sku", "url"])
    .execute()
    .await
    .unwrap();
distinct_attribute_guide_distinct_parameter_1: |-
  let res = client
    .index("products")
    .search()
    .with_query("white shirt")
    .with_distinct("sku")
    .execute()
    .await
    .unwrap();
search_parameter_reference_ranking_score_threshold_1: |-
  let res = client
    .index("INDEX_NAME")
    .search()
    .with_query("badman")
    .with_ranking_score_threshold(0.2)
    .execute()
    .await
    .unwrap();
search_parameter_reference_locales_1: |-
  let res = client
    .index("books")
    .search()
    .with_query("進撃の巨人")
    .with_locales(&["jpn"])
    .execute()
    .await
    .unwrap();
get_localized_attribute_settings_1: |-
  let localized_attributes: Option<Vec<LocalizedAttributes>> = client
    .index("books")
    .get_localized_attributes()
    .await
    .unwrap();
update_localized_attribute_settings_1: |-
  let localized_attributes = vec![LocalizedAttributes {
      locales: vec!["jpn".to_string()],
      attribute_patterns: vec!["*_ja".to_string()],
  }];
  let task: TaskInfo = client
    .index("books")
    .set_localized_attributes(&localizced_attributes)
    .await
    .unwrap();
reset_localized_attribute_settings_1: |-
  let task: TaskInfo = client
    .index("books")
    .reset_localized_attributes()
    .await
    .unwrap();
